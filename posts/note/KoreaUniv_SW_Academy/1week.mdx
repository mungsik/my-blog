---
title: 1주차 정리 -1
date: 2023-03-04
---

export const Highlight = ({children, color}) => (
    <span
        style={{
        backgroundColor: color,
        borderRadius: '5px',
        color: '#fff',
        padding: '0.2rem',
        }}>
        {children}
    </span>
    );

### Python 특징

    1. 효율적인 자료 구조들
    2. 객체 지향 프로그래밍
    3. 간단하고도 효과적인 접근법
    4. 동적 타이핑
        - 실행 시간에 자료형을 검사하는 것.
        - 자료형의 개념을 축소시킬 수 있지만(자료형의 타입을 지정하지 않고 자유롭게 사용하여 편리하고 빠르게 개발), 속도가 느리고 코드 힌트가 잘 되지 않거나 런타임 에러가 발생
        - 형변환의 개념이 타 언어에 비해서 유연함.
    5. 인터프리터적인 특징
        - 컴파일 언어 : 기계 언어에 최적화되어 있기 때문에 실행 속도가 빠르다
        - 인터프리터 언어 : 컴파일 언어와 반대
    6. 우아한 문법
        - 단순, 간편을 뜻함. 우아함이 단순함을 낳는다.
    7. 풍부한 표준 라이브러리
    8. 무료 + 자유롭게 배포 가능

### Python 문법

    1. **숫자**

        - 정수는 int형이다.
        - 소수는 float형이다.
        - 나눗셈(/)은 항상 float을 반환한다. 정수 결과를 얻으려면 //연산자를 사용하면 된다.
        - 나머지를 얻으려면 % 를 사용하면 된다.
        - 거듭제곱을 할 때 **연산자를 사용한다.

    2. **연산자 우선 순위**

    ![](/note/KoreaUniv_SW_Academy/1.PNG)

    3. **변수에 값 대입하기**

        - 변수에 값을 대입할 때는 등호(=)을 사용한다.
        - 파이썬에서는 변수보다는 식별자 또는 이름으로 통칭한다. 이는 파이썬의 모든 값은 객체이기 때문이기도 하다.
        - 등호를 사용하여 값을 할당하는 것을 <Highlight color="#FFB84C">binding, assignment</Highlight>라고 하고, 이에 관한 문장을 <Highlight color="#FFB84C">대입문</Highlight>이라고 한다.
        - 같은 이름에 다시 할당하는 것을 <Highlight color="#FFB84C">재할당</Highlight>이라고 하고, 재할당할 수 없는 값을 보통 상수라고 한다. <Highlight color="#FFB84C">파이썬에서는 기본적으로 상수가 존재하지 않는다.</Highlight>(Java의 Final과 같은 상수를 정의하는 키워드가 없음).
        - 기본적으로 파이썬의 변수 정의는 C언어와 달리 선언만으로 가능하지 않고, 선언과 동시에 할당이 이루어져야 한다.

        ![](/note/KoreaUniv_SW_Academy/2.PNG)

    4. **명명 규칙**

        - 키워드로 이름을 사용할 수 없다.
        - _을 제외, 숫자나 특수 문자가 이름의 첫 단어로 올 수 없다(_로 시작하는 이름은 특별한 의미를 지닌다).
        - 이 외 모든 유니코드 문자를 사용할 수 있으나, 호환성을 위해서 ASCII 코드를 이름에 사용하는 것이 권장된다.

    5. **키워드**

        ```python
        import keyword
        print(keyword.kwlist)
        ```

        로 확인할 수 있다.

    6. **coercion(코어션)**

        <Highlight color="#FFB84C">같은 형의 두 인자를 수반하는 연산이 일어나는 동안, 한 형의 인스턴스를 다른 형으로 묵시적으로 반환하는 것.</Highlight>예를 들어, int(3.15)는 실수를 정수 3으로 변환한다.
        하지만 3+4.5 에서 각 인자는 다른 형이고 둘을 더하기 전에 같은 형으로 변환해야 한다. 그렇지 않으면 TypeError를 일으킨다. 코어션 없이는, 호환되는 형들조차도 프로그래머가 같은 형으로 정규화해주어야 한다.
        예를 들어, 그냥 3+4.5 하는 대신 float(3) + 4.5

    7. **기본(builtin) 숫자형**

        - int
        - float
        - complex
        - bool (True, False)

        ![](/note/KoreaUniv_SW_Academy/3.PNG)

    8. **문자열**

        - 문자열은 인덱스(서브 스크립트) 될 수 있다. 첫 번째 문자가 인덱스 0에 대응한다.

            ```python
            word = 'Python'
            word[0]

            # 'P'
            ```

        - 인덱스는 음수가 될 수도 있는데, 끝에서부터 센다.

            ```python
            word = 'Python'
            word[-1]

            # 'n'
            ```

            <Highlight color="#FFB84C">음의 인덱스는 -1에서 시작한다는 것을 주의하자.</Highlight>

        - 인덱싱에 더해 슬라이싱도 지원한다. 인덱싱이 개별 문자를 얻는데 사용되는 반면, 슬라이싱은 부분 문자열을 얻는 데 사용된다.

            ```python
            word = 'Python'
            word[0:2]

            # 'Py'
            ```

            <Highlight color="#FFB84C">시작 위치의 문자는 항상 포함되는 반면, 종료 위치의 문자는 항상 포함되지 않는다.</Highlight>

            첫 번째 인덱스를 생략하면 기본값 0이 사용되고, 두 번째 인덱스가 생략되면 기본값으로 슬라이싱 되는 문자열의 길이가 사용된다.

            ```python
            word = 'Python'
            word[:2]

            # 'Py'

            word[4:]

            # 'on'
            ```
            ![](/note/KoreaUniv_SW_Academy/4.PNG)

        9. **리스트**

            - 인덱싱하고 슬라이싱 할 수 있다. 이 때, <Highlight color="#FFB84C">모든 슬라이스 연산은 요청한 항목들을 포함하는 새 리스트를 돌려준다.</Highlight> 이는 다음과 같은 슬라이스가 리스트의 <Highlight color="#FFB84C">새로운 얕은 복사본</Highlight>을 돌려준다는 뜻이다.

            ```python
            squares = [1,4,9,16,25]
            squares[:]

            # [1,4,9,16,25]
            ```python

            - 리스트는 가변이다. 즉, 내용을 변경할 수 있다.

            ```python
            cubes = [1,8,27,65,125]
            cubes[3] = 64
            cubes

            # [1,8,27,64,125]
            ```

            - 리스트를 중첩할 수도 있다.(다른 리스트를 포함하는 리스트를 만든다.)

            ```python
            a = ['a', 'b', 'c']
            n = [1,2,3]
            x = [a, n]
            x

            # [['a', 'b', 'c'], [1,2,3]]

            x[0]

            # ['a', 'b', 'c']

            x[0][1]

            # 'b'
            ```

        10. **for문**

            파이썬의 for문은 임의의 시퀀스(리스트나 문자열)의 항목들을 그 시퀀스에 들어있는 순서대로 이터레이션 한다.

            ```python
            active_users = {}
            for user, status in users.items():
                if status == 'active':
                    active_users[user] = status
            ```

        11. **range() 함수**

            숫자들의 시퀀스로 이터레이트할 필요가 있으면, 내장 함수 range()가 편하다.

            ```python
            for i in range(5):
                print(i)
            ```

        12. **루프의 break와 continue문, 그리고 else 절**

            try문의 else절은 예외가 발생하지 않을 때 실행되고, 루프의 else절은 break가 발생하지 않을 때 실행된다.

            ```python
            for num in range(2,10):
                if num % 2 == 0:
                    print("Found an even number", num)
                    continue
                print("Found a number", num)

            # Found an even number 2
            # Found a number 3
            # Found an even number 4
            # Found a number 5 ...
            ```

### 함수 정의하기

    > 재사용하기 위해서 정의하는 것을 선언한다고 하고, 이러한 명령 문장을 선언문이라고 한다. 파이썬에서는 대표적으로 함수, 클래스 선언이 있다.

    - 1. 독스트링(docstring)

        함수 바디의 첫 번째 문장은 선택적으로 문자열 리터럴이 될 수 있다.

        ```python
        def func(n):
            """docstring is possible"""
            a,b = 0,1
            while a < n:
                print(a,end=" ")
                a,b = b, a+b
        print()
        ```

    - 2. return 값

        ```python
        func

        # <function func at 10042ed0>

        func(0)
        print(func(0))

        # None
        ```

        return 문이 없는 함수도 값을 돌려준다. 이 값을 <Highlight color="#FFB84C">None</Highlight>값이라고 부른다.

### 함수 인자 값

    1. Parameter default value

    함수를 정의할 때 default value를 설정해주면 인수가 전달되지 않았을 때 해당하는 값으로 처리한다.


    ```python
    def ask_ok(prompt, retries=4, reminder='plz try again'):
    while True:
        ok = input(prompt)
        if ok in ('y', 'ye', 'yes'):
            return True
        if ok in ('n', 'no', 'nop', 'nope'):
            return False
        retries = retries - 1
        if retries <br 0:
            raise ValueError('invalid user response')
        print(reminder)

    ask_ok('파일을 덮어써도 좋습니까?', 4, '자, 예나 아니요로 답만하세요')

    # 자, 예나 아니요로 답만하세요
    # 자, 예나 아니요로 답만하세요
    # 자, 예나 아니요로 답만하세요
    # 자, 예나 아니요로 답만하세요
    # ValueError
    ```

    <Highlight color="#FFB84C">기본 매개변수를 설정하더라고 함수를 호출할 때 변경할 수 있다.</Highlight>

    <br></br>
    #### 잠깐!📢

    기본 매개변수를 사용할 때, 기본 매개변수를 non-defalut value parameter의 앞에 배치해야 한다

    ```python
    def average2(num1=5, num2, num3):
        result = (num1 + num2 + num3) / 3
        return result;

    # SyntaxError: non-default argument follows default argument
    ```

    2. Keyword Arguments

    함수를 호출할 때 매개변수 명칭을 직접 지정해서 인수를 넘겨주는 방식.

    ```python
    def set_user_info(name, age, gender, height):
        print(f"이름 : {name}")
        print(f"나이 : {age}")
        print(f"성별 : {gender}")
        print(f"신장 : {height}")

    set_user_info("ted", gender="남자", height=178, age=28)
    ```

    3. 특수 매개 변수

    > *, ** (asterick)에 대해 알아보자

        - *args

        1. 이 지시어는 여러 개의 인자를 함수로 받고자 할 때 쓰인다. 또한, 꼭 저 단어를 쓸 필요가 없다. *a 로 써도 되고 *name으로 써도 된다.

            <Highlight color="#FFB84C">몇 개의 인자를 받을 지 모를 때 주로 쓰인다!</Highlight>

            ```python
            def Name(*names):
                for name in names:
                    print("%s %s" (name[0], name[1:3]), end=' ')

            Name('메시', '호날두')

            # 메시 호날두
            ```

        2. args를 출력하면 **튜플** 형태로 나온다.

            ```python
            <class tuple>('메시','호날두')
            ```

        - **kwargs

        1. keyword arguments의 줄임말로 키워드를 제공한다.

        ```python
        def Keywords(**kwargs):
            for key, value in kwargs.items():
                print("{0} is {1}".format(key, value))


        Keywords(MyName = 'mungsik')

        # MyName is mungsik
        ```

        **kwargs는 `키워드 = 특정 값` 형태로 함수를 호출할 수 있다. 그것은 그대로 딕셔너리 형태인 `키워드 : 특정 값` 으로 함수 내부로 전달된다.

        응용하면 특정 키워드에 반응하는 함수를 만들 수 있다.

        ```python
         def SpecificKeywords(**kwargs):
            for key, value in kwargs.items():
                if 'func' in kwargs.keys():
                    print("미래의 머신러닝 엔지니어입니다")
                else: print("{0} is {1}".format(key,value))

        SpecificKeywords(MyName="mungsik")
        SpecificKeywords(func="mungsik")

        # MyName is mungsik
        # 미래의 머신러닝 엔지니어입니다.
        ```

        키워드(딕셔너리 key부분의 값이)가 func으로 들어왔을 때는 "미래의 머신러닝 엔지니어입니다"를 출력하여 나만의 서비스를 만들었다.

        2. 순서

        `*args는 일반 변수보다는 뒤에 위치해있어야 한다.` 즉, 맨 앞에 특정 변수를 명시해두고, 그 뒤에는 *args로 아규먼트를 넣어줘야 한다.

        - *args, **kwargs 둘 다 써보기

        ```python
        def blog_printer(name, *blogs, **blog_benefits):
            '''`
            name: 블로그 주인장 이름
            *blogs: 블로그를 만들 때 설명
            **blog_benefits: 해당 블로그의 수익
            '''

            print(name)
            for post in blogs:
                print(post)
            for blog, benefits in blog_benefits.items():
                print(blog, '수익은 >>', benefits)

        blog_printer('mungsik', '블로그1', '블로그2', '블로그3', 블로그수익1=30, 블로그수익2= 40, 블로그수익3=60)

        # mungsik
        # 블로그1
        # 블로그2
        # 블로그3
        # 블로그수익1 수익은 >> 30
        # 블로그수익2 수익은 >> 40
        # 블로그수익3 수익은 >> 60
        ```

    - **결론 및 요약**

        1. 함수 파라미터 순서 : 일반 변수, *변수, **변수
        2. *변수 : 여러 개가 아규먼트로 들어올 때, 함수 내부에서는 해당 변수를 '튜플'로 처리한다.
        3. **변수 : 키워드 = '' 로 입력할 경우에 그것을 각각 키와 값으로 가져오는 '딕셔너리' 로 처리한다.

    4. **위치 전용 매개 변수**

        > 위치 전용 매개 변수는 / (슬래시) 앞에 놓입니다. / 는 위치 전용 매개 변수를 나머지 매개 변수들로부터 논리적으로 분리하는 데 사용됩니다. 함수 정의에 / 가 없으면, 위치 전용 매개 변수는 없습니다. / 다음의 매개 변수는 위치-키워드나 키워드 전용일 수 있습니다.

        ```python
        # a와 b는 위치 전용, c와 d는 위치나 키워드, e와 f는 키워드 전용
        # * 뒤는 무조건 키워드 전용, / 뒤는 선택적임

        def func(a,b,/,c,d,*,e,f,):
            print(a,b,c,d,e,f)

        # 유효한 호출
        print(func(10,20,30, d = 40, e = 50, f =70))

        # 잘못된 호출
        print(func(10,b=20,c=30, d = 40, e = 50, f =70)) # b는 키워드 아규먼트가 될 수 없다.
        print(func(10, 20, 30, 40, 50, f=70)) # e는 키워드 아규먼트여야 한다.
        ```

        이 때, `/`의 왼쪽에 있는 매개변수는 가능한 키워드로 노출되지 않아서 매개변수 이름은 `**kwargs`에서 사용할 수 있다.

        ```python
        def func2(a, b, /, **kwargs):
            print(a, b, kwargs)

        func2(10, 20, a=1, b=2, c=3)

        # 10 20 {'a': 1, 'b': 2, 'c': 3}
        ```

### unpacking(*,** 사용)

    1. 기본 unpacking

    ```python
    a, b, c = [1, 2, 3]
    a
    b
    c

    # a = 1, b = 2, c = 3
    ```

    오른쪽에 위치한 리스트의 각 원소들이 위치에 상응하는 a, b, c에 들어가는 형태이다.

    unpacking은 리스트, 튜플, string, 딕셔너리 등 모든 iterable 형태의 데이터 타입들은 다 가능하다.

    - dictionary 형태는 unpacking 했을 때 key 값만 나온다.
    - 딕셔너리 뒤에 .values() 나 .items를 추가하면 value값 또는 (key, value)의 unpacking이 가능해진다.
    - `set`도 iterable 이기 때문에 unpacking이 가능하지만, 순서가 없는 데이터 타입이기 때문에 뒤죽박죽 할당되어 unpacking 하지 않는다.

    ```python
    a, b, c = {'key1':1, 'key2':2, 'key3':3}.values()
    a,b,c

    # 1 2 3
    ```

    2. *을 통해 unpacking

        - *가 왼쪽 변수에 있을 경우

            ```python
            a, *b, c = [1, 2, 3, 4, 5]

            a
            b
            c

            # 1
            # [2, 3, 4]
            # 5
            ```

            *의 기능은 <Highlight color="#FFB84C">*가 없는 변수가 값을 할당 받고 할당 받지 못한 나머지 값들을 모아 `리스트`로 만드는</Highlight> 기능을 한다.

            이 때, 오른쪽 컨테이너 타입이 튜플이 오든 set이 오든 상관없이 항상 리스트 형태를 부여받는다.

            ```python
            a, *b, c = {1, 2, 3, 4, 5}

            a
            b
            c

            # 1
            # [2, 3, 4]
            # 5
            ```

        ❗ 주의할 점

        왼쪽 변수 부분에는 *을 한 번만 사용 가능핟. 두 번 사용할 시 SyntaxError가 난다.

        ```python
        a, *b, *c = {1,2,3,4,5}

        a
        b
        c

        - 컨테이너 그 자체를 unpacking 하는 *

            ```python
            l1 = [1,2,3]
            l2 = [4,5,6]

            l3 = [*l1, *l2]

            l3

            # [1,2,3,4,5,6]
            ```

            *을 통해서 각 리스트에 있는 값들을 분해한 후 새로운 리스트에 담았다.

            *가 없었다면, 아래와 같이 결과값이 나오게 된다.

            ```python
            l1 = [1,2,3]
            l2 = [4,5,6]

            l3 = [l1,l2]

            l3

            # [[1,2,3], [4,5,6]]
            ```

            ❗ 주의할 점

            ```python
            l1 = [1,2,3]
            l2 = *1
            print(l2)

            # SyntaxError
            ```

            iterable 자체에 *를 넣는 경우는 값을 분리하는 것은 맞다. 그러나 튜플이든, 리스트든 어떤 것으로 둘러쌓야만 한다.

            ```python
            l1 = [1,2,3]
            l2 = *1,
            print(l2)

            # SyntaxError
            ```

            ✅ 튜플에서 () 괄호 사용

            파이썬은 기본적으로 리스트인지 튜플인지 정해놓지 않으면, 튜플로 기억한다.
            따라서 b = 1,2,3,4 로 해도 b = (1,2,3,4)로 자동적으로 저장한다.

            원소가 하나인 튜플을 만들 때 콤마를 잘 활용해야 한다.

            ```python
            type((1))
            <class 'int>

            type((1,))
            <class 'tuple'>
            ```

         - **를 통해 unpacking

            **는 딕셔너리를 unpacking 하는 목적으로 사용한다.

            ```python
            d1 = {'p':1, 'y':2}
            d2 = {'t':3, 'h':4}
            d3 = {'h':5, 'o':6, 'n':7}

            d = {*d1, *d2, *d3}
            d

            # {'h','n','y','t','o', 'p'}
            ```

            키 값만 가져온 것을 볼 수 있다.또한, set 형태로 값을 묶다보니 h가 두 개에서 한 개로 변한 것을 볼 수 있다.

            이 때, key와 value를 한 번에 보기 위해 사용하는 것이 **이다.

            ```python
            d1 = {'p':1, 'y':2}
            d2 = {'t':3, 'h':4}
            d3 = {'h':5, 'o':6, 'n':7}

            d = {**d1, **d2, **d3}
            d

            # {'p': 1,'y': 2,'t': 3,'h': 5,'o': 6,'n': 7,}
            ```

            여기서 **override** 개념이 적용된다.

            ✅ override

            ```python
            d1 = {'a': 1, 'b': 2}
            d2 = {'a': 10, 'c':3, **d1}

            d2

            # {'a': 1, 'c': 3, 'b': 2}
            ```

            <Highlight color="#FFB84C">d2 딕셔너리 내에 d1이 언패킹되면서 뒤이어 'a':1 이 들어오면서 먼저 정의되어있던 'a':10을 오버라이드 한다.</Highlight>

         - nested unpacking

            ```python
            list = [1, 2, [3, 4]]
            a, b, (c, d) = list
            a
            b
            c
            d

            # 1
            # 2
            # 3
            # 4

### PEP 8

    > 파이썬 코딩 스타일

    - 들여쓰기에 4-스페이스를 사용하고, 탭을 사용하지 말아라.
    - 79자를 넘지 않도록 줄 넘김을 해라.
    - 함수, 클래스, 함수 내의 큰 코드 블록 사이에 빈 줄을 넣어 분리해라.
    - 독스트링을 사용해라.
    - 연산자들 주변과 콤마 뒤에 스페이스를 넣고, 괄호 바로 안쪽에는 스페이스를 넣지말아라.
        `a = f(1,2) + g(3,4)`

    - 클래스와 함수들에 일관성 있는 이름을 붙여라.
        1. 클래스 : UpperCamelCase
        2. 함수와 메서드 : lowercase_with_underscore
        3. 첫 번째 메서드 인자의 이름으로는 항상 self를 사용해라.

### 자료 구조

    > dir() 함수를 통해서 사용 가능한 메소드를 확인할 수 있다.

    ![](/note/KoreaUniv_SW_Academy/5.PNG)

    위 메서드 둘 중 insert, remove, sort 같은 메서드들은 리스트를 수정할 분 반환 값이 출력되지 않는다. **기본 None**을 돌려주고 있는 것이다.
