---
title: 2주차 정리 - 3
date: 2023-03-08
---

export const Highlight = ({children, color}) => (
    <span
        style={{
        backgroundColor: color,
        borderRadius: '5px',
        color: '#fff',
        padding: '0.2rem',
        }}>
        {children}
    </span>
    );

### Generators

    - 반복 가능한 객체 (Iterable)
    - 반복자 (Iterator)
    - 반복 (Iteration)

    1. 반복 가능한 객체 (Iterable)

    반복 가능(`iterable`)은 반복자를 반환하거나 인덱스를 취할 수 있는 `__iter__` 또는 `__getitem__` 메소드가 정의 된 파이썬의 모든 객체이다.

    즉, 반복가능(iteralbe)은 반복자(iterator)를 제공할 수 있는 모든 객체이다.

    2. 반복자(Iterator)

    이터레이터는 `next` 혹은 `__next__` 메소드가 정의된 모든 객체이다.

    3. 반복(Iteration)

    리스트 같은 저장소에서 아이템을 가져오는 과정. 만약 루프에서 루프로 어떤 것을 옮기면 이것이 바로 이터레이션이다.

    즉, 과정 자체가 이터레이션이다.

    4. Generators

    제너레이터는 이터레이터지만 단 한 번만 반복한다. for루프를 사용하거나 반복하는 함수나 구조에 생성된 값들을 전달하여 반복을 통해 사용한다. 대부분의 제너레이터들은 함수로 구현되지만, 값을 <Highlight color="#FFB84C">반환하지 않고 산출(yield)할 뿐</Highlight>이다.

    제너레이터는 모든 결과물들을 메모리에 저장하지 않으면서 동시에, 많은 양의 결과 셋을 계산해야할 때 좋다.

    ```python
    def fibon(n):
        a = b = 1
        for i in range(n):
            yield a
            a, b = b, a+b

    for x in fibon(10000):
        print(x)
    ```

    ✅ next()

    `next()` 함수는 시퀀스의 다음 요소에 접근할 수 있게 해준다.

    ```python
    my_string = "soccer"
    next(my_string)

    # TypeError: 'str' object is not an iterator
    ```

    `str`은 반복가능(iterable) 하지만 이터레이터는 아니다. 즉, <Highlight color="#FFB84C">반복(iteration)은 지원하지만 직접 반복시킬 수는 없다는 것이다.</Highlight>
    이 것을 반복시키기 위해선 `iter` 이라는 내장함수를 알아야한다.

    ✅ iter()

    `iter()` 함수는 반복가능(iterable)으로부터 `이터레이터` 객체를 반환한다. 이 때, 정수형은 반복가능하지 않기 때문에, 문자열을 사용해야한다.

    ```python
    ...
    my_iter = iter(my_string)
    print(next(my_iter))
    print(next(my_iter))
    print(next(my_iter))
    print(next(my_iter))
    print(next(my_iter))
    print(next(my_iter))

    # s
    # o
    # c
    # c
    # e
    # r
    ```

###  vars() vs. dir()

    - vars와 dir 함수 둘 다 파이썬 클래스의 인스턴스 / 객체 속성을 나열하는데 사용됨.
    - dir() 함수
        1. vars() 함수보다 더 많은 속성을 보여줌
        2. 인스턴스와 클래스 속성을 보여줌
        3. 조상 클래스의 속성을 보여줌
    - vars() 함수
        인스턴스의 속성을 dictionary 형태로 보여줌.
    - vars() 함수는 언제 사용하는가?
        print 명령어를 사용할 때 object인 경우 내용을 볼 수 없는 형태가 되는 경우가 있는데 이 때 사용하면 된다.

    ![](/note/KoreaUniv_SW_Academy/22.PNG)

    ✅ __dict__

    - 객체의 변수를 dict 형태로 변경할 수 있다.

    ```python
    class Test:
	def __init__(self, name):
		self.name = name
		self.test_dict = {'a':1, 'b':2}
		self.test_list = ['1','2','3']

    # Test 객체 생성
    test_object = Test("mungsik")

    # __dict__ 메소드를 이용해보면 type이 dict인 것을 확인 할 수 있다.
    print(type(test_object.__dict__)) # `<class 'dict'>`

    # print 해보면, 객체에 선언한 변수들이 key,value로 들어간 것을 확인할 수 있다.
    print(test_object.__dict__)  # `{'name': 'mungsik', 'test_dict': {'a': 1, 'b': 2}, 'test_list': ['1', '2', '3']}`

    # dict 형태이기 때문에 key 값으로 조회시 바로 value를얻을 수 있다.
    print(test_object.__dict__['name']) # mungsik
    ```

### delegation, composition, mro, 상속, 덕타이핑, comprehension, 정규식


### 메타 클래스

    메타클래스는 클래스를 만드는 클래스인데, 이 메타클래스를 구현하는 방법은 두 가지가 있다.

        1. `type`을 사용하여 동적으로 클래스를 생성하는 방식
        2. `type`을 상속 받아서 메타클래스를 구현하는 방식

    `type`은 객체의 클래스(자료형) 종류를 알아낼 때도 사용할 수 있고, 클래스를 만들어낼 수도 있다.

    클래스 = type('클래스 이름', 기반클래스튜플, 속성메서드딕셔너리)

    ```python
    MetaClass = type('MetaClass', (), {}) # type으로 클래스 MetaClass 생성
    MetaClass # __main__.MetaClass

    meta = MetaClass() # 클래스 MetaClass 로 인스턴스 meta 생성
    meta # <__main__.MetaClass at 0x1b583889e40>
    ```

