---
title: Algorithms
date: 2022-10-25
---

# Big 0 알고리즘 복잡도

## 알고리즘 복잡도

알고리즘을 평가하는 척도로 사용되는 복잡도(complexity)라는 개념이 있다.

알고리즘의 복잡도의 개념은 코드의 길이보다는 코드를 실행했을 때의 성능과 효율, 확장성(scalability)에 관계가 깊다.
알고리즘의 복잡도를 분석할 때는 시간 측면에서는 얼마나 실행 속도가 빠른지를 보기도 하고, 공간 측면에서는 얼마나 많은 메모리가 쓰이는지를 보기도 한다.
전자를 **시간 복잡도(time complexity)** 라고 하고, 후자를 **공간 복잡도(space complexity)** 라고 한다.

일반적으로 처리할 데이터의 양이 많아질수록 대부분의 경우 알고리즘의 성능은 떨어지기 마련이다. 여기서 중요한 부분은 입력 데이터 증가량 대비
얼마큼의 실행 시간과 메모리 소모량이 늘어나는 지이다. 우수한 알고리즘일수록 처리할 데이터의 양이 증가함에 따라 성능 저하가 적게 나타나는 경향을 보인다.

알고리즘의 성능을 비교할 때 일반적으로 입력 데이터의 크기가 작을 때는 어떤 알고리즘이 우수한지 티가 잘 안 나지만,
입력 데이터의 크기가 커지면 커질수록 시간 복잡도가 높은 알고리즘은 오래 걸리고 공간 복잡도가 높은 알고리즘은 메모리를 많이 쓰게 된다.

## Big 0

최악의 조건에서 주어진 알고리즘이 입력 데이터 크기 대비 실행 시간이나 메모리 사용량이 얼마나 증가하는지를 수식으로 표현한다.

Big 0를 사용해서 복잡도를 분석할 때는 거시적으로 접근하면서 수식을 단순화시킨다. 예를 들어, 어떤 알고리즘에 크기가 `n`인 데이터가 주어졌을 때,
실행 시간이 `$3n^2 + 5n + 100$` 으로 계산된다면, Big 0 계산법으로 $O(n^2)$ 가 된다. 즉, Big O 표현식에서는 수학적으로 가장 영향력이 큰 항만 고려되며,
그 항 앞에 붙은 상수도 의미가 없어지게 된다.

```python
def solution(bridge_length, weight, truck_weights):
    q=[0]*bridge_length
    cnt=0
    sum=0
    while q:
        sum-=q.pop(0)
        cnt+=1
        if truck_weights:
            if sum+truck_weights[0]<=weight:
                sum+=truck_weights[0]
                q.append(truck_weights.pop(0))
            else:
                q.append(0)
    return cnt
```
